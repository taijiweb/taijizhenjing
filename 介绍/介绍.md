非正式文档状态声明

本文件夹包含的所有文档都处于草稿状态，可能已过时，不完整，不准确甚至不正确。在发布新的声明之前，所有文档目前权当非正式的参考，不作为任何依据，阅读者敬请留意此声明。

介绍

太极语言的源与流

本书的目的
  本书的目的是作为太极语言的一个非正式规范。既是规范，然而又是非正式的。犹如专利法律文书中说明书所起的作用。对照于专利的权利要求书，专利说明书本身不具有正式的法律效力，然而它作为法律文书的一部分，它可以作为权利要求书的解释依据，是实现、介绍和应用专利，解决分歧的一个参考。

本书的体系
  心法篇：介绍与太极语言有关的基本概念，是从整体上掌握太极语言的基础内容。
  拳脚篇：介绍太极语言包括的各种构造。
  内功篇：太极语言的高级技术，包括编译时间计算，重定义语言等内容
  兵器篇：实战中的太极语言技术：用太极语言作为模板语言，太极语言web开发框架，太极语言与html，太极语言与css等。

体例

正名  
  必也正名乎
  本书很多地方花费了不少文字介绍概念，谈到可能用到的术语和名词。名可名，非常名。由于历史的原因和交流的需要，同一个对象，可能会有不同的名词来称呼它。请读者在阅读本书的时候，多注意这些正名的内容。既要注意名字本身，更要联系上下文仔细琢磨名字引起的意义。

非正式文档状态声明

本文件夹包含的所有文档都处于草稿状态，可能已过时，不完整，不准确甚至不正确。在发布新的声明之前，所有文档目前权当非正式的参考，不作为任何依据，阅读者敬请留意此声明。

语言概览
  上帝说：要有0和1，0和1就产生了。
  上帝说：要有硬件和软件，然后就有了硬件和软件，人们管这叫电脑。
  上帝说：要有程序和数据。然后程序和数据就出现了。
  上帝说：要有编程语言，然后fortran，lisp等等许多编程语言一个一个出现了。
  上帝说：要有程序员和程序媛。然后程序员和程序媛就坐在了电脑前面。
  第六天，上帝累了，第六天和第七天就是双休日。但是因为程序员和程序媛是第五天创造出来的，所以他们第六天和第七天也在工作。

javascript 穿上一层lisp的衬衣，然后外面在套一件类似python缩进语法的外套。

（coffeescript，haskell等同样语法特点的语言）

中间表示

灵活的语法
  运算表达式
  缩进表达式

解析
  解析结果的格式
  对解析结果的变换

编译

优化
  优化指令
    循环外提
    函数外提
  编译时间计算
    无io作用的代码段
  尾递归优化，普通递归优化

# optimization 1:
# if 1 then a else b ---> a
# if 0 then a else b --> b
# 1+2 -> 3, etc.
# a and not a
# while 0, 1==0, 1==2, false, undefined, null, '', etc

# optimization 2:
# below need a has no side effects ( a is not function call(), etc.)
# if a then if a then b else c  ---> if a then b
# if a then if not a then b else c  ---> if a then c
# if not a then if a then b else c ---> if not a then c
# if not a then if not a then b else c ---> if not a then b
# if (if a then b else c) then d else e # no optimzation
# if (if a then b else c) then if a then d else e  -->
# if a then if b then d
# else then if c then e
# while 0, while false

# optimization 3: assign optimization
# property optimization is not executed: be careful that getter, setter, watcher
# short distance
# conservative  

http://www.refactoring.com/catalog/replaceIterationWithRecursion.html
greatest_commonDivisor = (a, b) ->
  if (a > b) then return greatest_commonDivisor(a-b, b)
  else if (b > a) then return greatest_commonDivisor(a, b-a)
  else return a

greatestCommonDivisor = (a, b) ->
  while 1
    if (a > b) then a -= b
    else if (b > a) b -= a
    else return a
