# 元编译

太极语言的元编译功能是一个很曲折而且很有兴味的一个过程。因此，我觉得花点时间描述这个过程是有意义的。

最开始，我只希望太极语言具有和lisp同样功能的宏就够了，并没有将现有各项元编译功能作为太极语言最初设计目标，甚至没有意识到关于所有这些元算符的概念。当时，我对元编译的概念主要源自于对于metalua的某些了解，仅此而已。

在实现太极语言的某个阶段，我发现了可以在编译时间对太极语言的某些部分代码求值，比如1+1这样的代码块。然后，我进一步想到，象if-else-语句这类语句可以用来在编译时间控制目标代码的生成，并自然地联想到C/C++的预处理，比如#if, #define等预处理语句。同时，也基于对metalua的了解，我实现了类似的功能。与太极语言的语法相适应，我为这项功能选择了与metalua不同的符号`#`和`##`。这两个符号的选用应该说来源于C/C++预处理。在此之前，我是用#作为太极语言的行注释引导符。因此，我废除了使用“#”作为注释引导符号的决定，用它来作为预处理语句的算符。而“##”则成为直接元编译算符。实现这两个算符以后，我开始经常思索这种元编译和lisp的宏功能之间的关联。

上述元算符最开始的实现方法和最终的实现大不相同。最开始，元编译阶段直接产生目标代码的编译表示，如果遇到了上述元算符，它们将被变换成一个赋值语句，赋值语句的左边是metaList[index], 右边是元代码。该赋值语句整体被编译成javascript代码存放在一个数组中，而编译表示中以[meta! index]代表这个数组的这一项。然后在元编译的后处理阶段，将所有这些代码片段串接成一个完整的程序，执行这个程序的效果是将产生metaList数组，编译变换步骤会利用metaList将[meta! index]转换成对应的结果，产生表达式变换的输入中间表示。

宏功能的最初实现并没有采用上述元编译的方法，而是一个与此无关的并行实现。这种宏功能的实现方法也是我依据lisp宏实现的相关资料并经自己改进而得到的。该方法是将与宏名对应的函数记录在编译过程的变量环境（Environment，env）之中，而不是作为元编译代码一部分。当发现变量是宏函数的时候，按照宏调用的要求执行该函数得到作为编译变换步骤的中间表示的一部分。

上述方法的问题是元编译代码被分割成了一些碎片，失去了作为一个程序应该有的整体结构。另外，我的直觉也意识到，宏可以成为元编译的一个特例。这两个方面成为我后来思考的重点。经过很长时间之后，终于有了线索。我发现可以将上述方法进行一个逆转，即将元编译程序作为一个整体，而运行时间程序的编译表示作为元编译程序的处理数据。我意识到这是一个更完整，更强大的实现。依据这个想法，我对于元编译步骤做了重构，得到了现在的实现。

消元算符的发现和太极语言的模块特性的实现过程很有关系。基于最初的宏实现，太极语言有一个简单而不够完整的模块实现。得到新的元编译实现之后，我发现它也可以帮组我彻底解决原来的模块实现中的问题。我开始着手编码这个实现。实现过程中，我发现必须将需要导入的模块同时在编译时间和运行时间封包在函数中。因此，在已经用元算符封包整个函数之后，必须在其中取消运行时间代码的封包。由此，我自然而然的想到了消元算符。并选择了`#-`作为它的符号。因为这个算符的发现，我开始了一轮头脑风暴并发现了一些别的元算符，例如：`#/`, `#/=`, #call!等等。