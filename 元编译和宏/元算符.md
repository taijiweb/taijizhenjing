# 元算符

## 元算符介绍

太极语言提供了一组元算符，包括#，##，#/，#&，#/=，#&=，#-等。本章将解释这些算符的功能和用法。

`##`: 编译时间求值算符。或者称之为元求值算符。`##exp` 或者 `## clause`表示在编译时间求值表达式或子句。

`#`: 预处理算符。它的功能和C/C++预处理的功能有类似之处，在元编译时对程序做某些处理。如果#后面跟随的不是预处理的几种语句(if, while, let等), 则和等同于`##`。

`#/`: 编译时间和运行时间求值算符，简称跨元算符。`#/{ x + y }`等价于`#{ x + y }`; x + y;

`#=`: 编译时间赋值算符，简称元赋值。`x #= y` 等价于 `#{ x = y }`, 在编译时间将y赋值给x。

`#/=`：编译时间和运行时间赋值算符，简称跨元赋值。`x #/= y` 等价于 `#{ x = y }; x = y`, 在编译时间将y赋值给x。

`#-`: 退出编译时间求值算符，简称退元算符。在元编译的代码块中使用此算符，可以将此算符引导的算符表达式或子句转到运行时间求值。因此 `# #- x + y`等价于`x +y`

`#call!`: 宏调用算符。列表式 [#call! arg1 arg2 args...]是宏调用。实际代码中，marcroFunc#(arg1, arg2, args...)将被解析为列表式[#call! arg1 arg2 args...]。也可以写成更简单的形式：marcroFunc # arg1 arg2 arg3...。宏调用的功能是要求太极语言在编译时间先进行宏扩展，然后依据宏扩展的结果产生目标代码。宏扩展的方法是在编译时间调用不求值参数，将其直接传给函数进行计算获得结果。

`#&`: 编译时间求值和运行时间

## 元算符使用示例

```taijilang
##(1+1)
```
在元编译时间求值1+1

```taijilang
#(1+1)
```
在元编译时间求值1+1。

```taijilang
# (#(1+2) + #(3+4))
```
多重元算符等效于一重元算符，因此上述表达式相当于`#((1+2)+(3+4))

```
#(1+2) + #(3+4)
```
产生目标代码`3+7`

```
3+.#(1+1)
```
用`.`将`+`和`#`分隔为两个符号。

```
# ~ 1+1
```

```
##a=1
```
`##`的优先级低于`=`，因此上式相当于`##(a=1)`。也可以写成`## a=1`。

```
#(a=1)
```
等价于前一个示例。
```
a#=1
```
元编译时间赋值。

```
a#=1;#a
```

```
## if 1 then 1 else 2
```

```
if 1 then #1+2 else #3+4
```

```
if 1 then ##1+2 else ##3+4
```

```
compileNoOptimize if 1 then ##1+2 else ##3+4
```

```
array? #= (obj) -> ` (Object::toString.call(^obj) == '[object Array]')
```

```
array? # 1
```

```
array? # []
```

```
`# if 1 then a else b` 
```

编译上述代码时将会报告错误：`fail to look up symbol from`environment:a

```
#  #-{ print 1 } 
```

上述代码的编译结果是 `console.log(1)`


```
#{ -> #- { print 1 }})() 
```

上述代码的编译结果是`[print, 1]`
